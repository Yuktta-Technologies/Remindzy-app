package com.app.reminderpro.model

import android.util.Log
//import androidx.compose.runtime.mutableStateOf // Ensure this is commented out or removed
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.app.reminderpro.alarm.ReminderScheduler
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

class ReminderViewModel(
    private val repository: ReminderRepository,
    private val scheduler: ReminderScheduler
) : ViewModel() {

    companion object {
        private const val TAG = "ReminderViewModel"
    }

    val allReminders: StateFlow<List<Reminder>> = repository.allReminders
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000L), emptyList())

    //    var showAddReminder = mutableStateOf(false) // MAKE SURE THIS LINE IS DELETED OR COMMENTED OUT

    private val _needsExactAlarmPermission = MutableStateFlow(false)
    val needsExactAlarmPermission: StateFlow<Boolean> = _needsExactAlarmPermission.asStateFlow()

    private val _exactAlarmPermissionOutcome = MutableStateFlow<Boolean?>(null)
    val exactAlarmPermissionOutcome: StateFlow<Boolean?> = _exactAlarmPermissionOutcome.asStateFlow()

    private var pendingReminder: Reminder? = null

    private fun scheduleReminderInternal(reminderToSchedule: Reminder) {
        viewModelScope.launch {
            Log.d(TAG, "Attempting to schedule reminder internally: ID ${reminderToSchedule.id}")
            // Consider if scheduler.schedule needs to know about nullable endTime
            // For now, assuming it primarily works off startTime and repeatMode for setting the alarm
            val scheduledSuccessfully = scheduler.schedule(reminderToSchedule)

            if (!scheduledSuccessfully) {
                Log.w(TAG, "Scheduling failed for reminder ID ${reminderToSchedule.id}, exact alarm permission likely needed.")
                pendingReminder = reminderToSchedule
                _needsExactAlarmPermission.value = true
            } else {
                Log.i(TAG, "Reminder ID ${reminderToSchedule.id} scheduled successfully by ReminderScheduler.")
                pendingReminder = null
            }
        }
    }

    fun deleteReminder(reminder: Reminder) {
        viewModelScope.launch {
            repository.delete(reminder)
            scheduler.cancel(reminder) // Ensure alarm is cancelled
            Log.i(TAG, "Reminder ID ${reminder.id} deleted and alarm cancelled.")
        }
    }

    // updateReminder already accepts a Reminder object, which will have the nullable endTime
    // if Reminder.kt and the UI layer (AddReminderDialog -> ReminderListScreen) are updated.
    fun updateReminder(reminder: Reminder) {
        viewModelScope.launch {
            repository.update(reminder) // The 'reminder' object here should already have the correct nullable endTime
            // Cancel the old alarm before scheduling a new one for updates
            scheduler.cancel(reminder) // Use the state of the reminder *before* potential ID change if scheduling a copy
            Log.d(TAG, "Old alarm for reminder ID ${reminder.id} cancelled. Attempting to reschedule.")
            scheduleReminderInternal(reminder) // Reschedule with the (potentially) updated reminder
        }
    }

    // Key change: endTime parameter is now Long?
    fun insertReminder(
        title: String,
        desc: String,
        startTime: Long,
        endTime: Long?,         // <<<< CHANGED: Now nullable Long?
        repeatMode: RepeatMode
    ) {
        // Create the Reminder object with the (now nullable) endTime
        val newReminder = Reminder(
            title = title,
            description = desc,
            startTime = startTime,
            endTime = endTime,      // <<<< Use the nullable endTime parameter here
            repeatMode = repeatMode
            // id is auto-generated by Room
        )
        viewModelScope.launch {
            val generatedId = repository.insert(newReminder)
            // It's good practice to use the returned reminder or reminder with its actual ID for scheduling
            val reminderWithId = newReminder.copy(id = generatedId.toInt())
            Log.d(TAG, "New reminder created with ID: ${reminderWithId.id}. Proceeding to schedule.")
            scheduleReminderInternal(reminderWithId)
        }
    }

    fun onExactAlarmPermissionPromptHandled() {
        Log.d(TAG, "Exact alarm permission prompt has been handled by UI.")
        _needsExactAlarmPermission.value = false
    }

    fun onExactAlarmPermissionGranted() {
        Log.i(TAG, "Exact alarm permission is now GRANTED.")
        _exactAlarmPermissionOutcome.value = true
        pendingReminder?.let {
            Log.i(TAG, "Retrying to schedule pending reminder: ID ${it.id}")
            scheduleReminderInternal(it)
        }
        // pendingReminder = null // Clear pending reminder after attempting to schedule it
    }

    fun onExactAlarmPermissionDenied() {
        Log.w(TAG, "Exact alarm permission is DENIED.")
        _exactAlarmPermissionOutcome.value = false
        pendingReminder = null // Clear pending reminder as permission was denied
    }

    fun clearPermissionOutcome() {
        Log.d(TAG, "Clearing exactAlarmPermissionOutcome by UI request.")
        _exactAlarmPermissionOutcome.value = null
    }
}
